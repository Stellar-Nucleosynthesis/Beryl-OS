BERYL FILE SYSTEM

How the file system functions:
In Beryl, the abstraction for block I/O devices is files. A file is an ordered set of disk blocks, each 512 bytes-long. Every disk allocation done deals with 512-byte blocks.
Every file is represented by an f-node, 512 bytes long, located somewhere on the disk. The structure of a typical f-node is:

[file owner: 1 byte][file type: 1 byte][file permissions: 1 byte][file links: 1 byte][file size: 5 bytes][reserved for future use: 7 bytes][disk block list: 496 bytes]

>File owner: File owner's ID. File's owner has full control over the file and it's settings, e.g. file permissions.
>File type: Indicates file type, e.g. a directory. 
>File permissions: Only 4 bits are used. Bits 0x8, 0x4, 0x2: permissions for other users to read, write, execute the file respectively; bit 0x1 - if set, indicates that the file will execute with it's owner's privileges.
>File links: The number of files defined by this f-node. 
>File size: 40-bit value, which represents the actual file size in bytes.
>Reserved for future use: Requires no clarification. Also serves as a padding to 128 bytes.
>Disk block list: A list of disk blocks that contain the file's data. If file size is no more than 496 bytes, it's actual content is stored here instead of pointers. Otherwise, the following scheme is used: 
The first 320 bytes are used to store 40 pointers to disk blocks with actual file data. The total of 20 KB can be stored here.
The next 40 bytes are used to store 5 pointers to trees with depth 1 (i.e. 5 pointers to disk blocks which are filled with pointers to disk blocks with actual file data). The total of 160 KB can be stored here.
The next 40 bytes are used to store 5 pointers to trees with depth 2. The total of 10 MB can be stored here.
The next 40 bytes are used to store 5 pointers to trees with depth 3. The total of 640 MB can be stored here.
The next 40 bytes are used to store 5 pointers to trees with depth 4. The total of 40 GB can be stored here.
The last 16 bytes are used to store 2 pointers to trees with depth 5. The total of 1 TB can be stored here.
Any unused pointers must be filled with null bytes.
All in all, 62 pointers can be present in a typical f-node. Despite the fact that theoretically more than 1 TB can be stored in one file, the actual limit is strictly 1 TB, as file size field is only 5 bytes long.

Two data structures, essential for the functioning of the file system are free block bitmap and f-node table. 
    Free block bitmap is self-explanatory: it is a bitmap, which has a specific bit set, if it's corresponding disk block is currently in use. Because one bit is used for every 512 bytes, it is very efficient in terms of disk space: less than 0,025% of disk's capacity.
    F-node table is a 3-layered tree containing pointers to all of the system's f-nodes. Beryl's file system can contain a bit less than 2^21 files, or around 2 million. Primary array, 1 KB long, contains pointers to other arrays, which contain pointers to other arrays, which actually contain pointers to f-nodes. Every array contains 127 entries, not 128, as first 8 bytes are used to store information about the number of free entries in tree section which this array starts.
An example of an f-node table if arrays were 32 bytes wide, not 1 KB:
Primary array (level 0):     [25][p0][null][null]
                                  /
Secondary array (level 1):       [7][p0][null][null]
                                     /
Secondary array (level 2):          [1][p0][null][p1]

Count value in the level 2 array is 1 because only 1 empty space is left. Count value in the level 1 array is 7, because p0 array has 1 empty space, and 2 other entries can contain 3 spaces each. Count value in the level 0 (primary) array is 25, as 7 free entries are present in p0 array, and each of the other (null) arrays can contain 9 entries.

Types of files:
1) Ordinary files: Files, containing data used by users and programs.
2) Directories: Lists of other files from users' perspective, in reality - files, containing information about f-nodes of other files. Directories form hierarchy of a file system.
3) Symbolic links: Files, containing paths to other files.
4) Binded files: different file defined by one f-node. From users' perspective - when they change one file, the other one also changes.

Ordinary files:
Ordinary files require no clarification.

Directories:
Every directory contains a list of following structures:

[file name: 35 bytes][file extension: 5 bytes][file ID: 4 bytes][reserved for future use: 4 bytes]

>File name: The file name in written in printable ASCII characters, but can't contain '.' or '/' characters, as they are reserved for use in extensions and file paths respectively. Max file name length is 35 bytes; if it's size is less than 35 bytes, the rest must be filled with null bytes.
>File extension: The file extension characterizes the format of data in the file. The file extension in written in printable ASCII characters, but can't contain '.' or '/' characters. Max file extension length is 5 bytes; if it's size is less than 5 bytes, the rest must be filled with null bytes.
>File ID: Global unique identifier of the file. It corresponds to the file's number in f-node table. Max value of this field is 2^20, not 2^32.
>Reserved for future use: Requires no clarification. Also serves as a padding to 48 bytes.

Symbolic links:
Simply files, containing a path to another file. When a symbolic link is opened, the file it is pointing to is opened instead.

Binded files:
Different files defined by one f-node. If one file is deleted, the other ones don't change. If one file is changed, the other ones also change. Binded files can have different names or even extensions.